package model;

import java.util.Stack;

/**
 * Game Class
 * Handles the game initialization, the main game loop and the ending condition
 */
public class Game {
    public enum Status {
        CHECKMATE, STALEMATE, CONTINUE
    }

    // Constants
    public final static int NUM_PLAYERS = 2;

    public Player[] getPlayers() {
        return players;
    }

    // Object Members
    private Player[] players;
    private Board board;
    private int currRound;
    private boolean isStarted;
    private Stack<Command> cmdExecuted;

    /**
     * Constructor of Game by the names of the players and the input stream of user input
     */
    public Game(boolean custom) {
        players = generatePlayers();
        board = new Board(players, custom);
        cmdExecuted = new Stack<>();
        currRound = 0; // Player White(0)'s round first by default
        isStarted = false;
    }

    public boolean isStarted() {
        return isStarted;
    }

    public void start() {
        isStarted = true;
    }

    public void restart(boolean custom) {
        for (Player player : players) player.clearPieces();
        board.initiate(players, custom);
        cmdExecuted.clear();
        currRound = 0;
    }

    /**
     * Getter of currRound
     * @return The current round number of this game
     */
    public int getCurrRound() {
        return currRound;
    }

    public Player getCurrPlayer() {
        return players[currRound];
    }

    /**
     * Setter of players
     * @param players The players of this game
     */
    public void setPlayers(Player[] players) {
        this.players = players;
    }

    public Board getBoard() {
        return board;
    }

    /**
     * Setter of board
     * @param board The board that records the status of this game
     */
    public void setBoard(Board board) {
        this.board = board;
    }

    public void alternateRound() {
        currRound = (currRound + 1) % NUM_PLAYERS;
    }

    /**
     * Checks the ending condition of this game
     * @return True if a player is checkmated or stalemated
     */
    public Status getStatus() {
        return board.isCheckmateOrStalemate(getCurrPlayer());
    }

    public void recordCommand(Command cmd) {
        cmdExecuted.push(cmd);
    }

    public boolean undoLastCommand() {
        if (cmdExecuted.isEmpty()) return false;
        board.undoCommand(cmdExecuted.pop());
        return true;
    }

    /**
     * Generator of Players from their names, setting each other to be opponents
     * @return The Players generated by their names
     */
    public static Player[] generatePlayers() {
        Player[] players = new Player[NUM_PLAYERS];
        players[0] = new Player(0);
        players[1] = new Player(1);
        players[0].setOpponent(players[1]);
        players[1].setOpponent(players[0]);
        return players;
    }
}

